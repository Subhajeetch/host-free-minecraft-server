<!DOCTYPE html>
<html>

<head>
    <title>Minecraft Crossplay Server Manager</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-2px);
        }

        .status-card {
            text-align: center;
            padding: 30px;
            background: rgba(0, 0, 0, 0.3);
        }

        .status-indicator {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5em;
            transition: all 0.3s ease;
        }

        .status-offline {
            background: #f44336;
        }

        .status-starting {
            background: #ff9800;
            animation: pulse 2s infinite;
        }

        .status-online {
            background: #4CAF50;
        }

        .status-stopping {
            background: #9e9e9e;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.1);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading {
            animation: spin 2s linear infinite;
        }

        .status-text {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .uptime {
            opacity: 0.8;
            font-size: 0.9em;
        }

        .button {
            padding: 12px 25px;
            margin: 8px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            transition: all 0.3s;
            font-size: 16px;
        }

        .button:hover {
            transform: translateY(-2px);
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .start {
            background: #4CAF50;
            color: white;
        }

        .stop {
            background: #f44336;
            color: white;
        }

        .info {
            background: #2196F3;
            color: white;
        }

        .connection-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .connection-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .connection-type {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #ffd700;
        }

        .ip-address {
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            word-break: break-all;
        }

        .copy-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
        }

        #console {
            background: #000;
            color: #0f0;
            padding: 15px;
            height: 300px;
            overflow-y: scroll;
            font-family: 'Courier New', monospace;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
        }

        #commandInput {
            width: 70%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            margin-right: 10px;
            font-size: 14px;
        }

        .port-forwarding-info {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .warning {
            color: #ffc107;
            font-weight: bold;
        }

        .hidden {
            display: none;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }

            .connection-info {
                grid-template-columns: 1fr;
            }

            #commandInput {
                width: 60%;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ Minecraft Crossplay Server Manager</h1>
            <p>Java Edition + Bedrock Edition Support | Friends Welcome!</p>
        </div>

        <!-- Server Status Card -->
        <div class="card status-card">
            <div id="statusIndicator" class="status-indicator status-offline">
                ‚èπÔ∏è
            </div>
            <div id="statusText" class="status-text">Server Offline</div>
            <div id="uptime" class="uptime hidden">Uptime: 0s</div>

            <div style="margin-top: 30px;">
                <button id="startBtn" class="button start" onclick="startServer()">üöÄ Start Server</button>
                <button id="stopBtn" class="button stop" onclick="stopServer()" disabled>‚èπÔ∏è Stop Server</button>
                <button class="button info" onclick="refreshStatus()">üîÑ Refresh</button>
            </div>
        </div>

        <!-- Connection Information -->
        <div id="connectionInfo" class="card hidden">
            <h3>üåê Connection Information</h3>
            <div class="connection-info" id="connectionGrid">
                <!-- Dynamic connection cards will be inserted here -->
            </div>

            <div class="port-forwarding-info">
                <h4 class="warning">üìã For Friends to Join Online:</h4>
                <p>1. <strong>Port Forwarding:</strong> Configure your router to forward ports 25565 (Java) and 19132
                    (Bedrock)</p>
                <p>2. <strong>Share Public IP:</strong> Give your friends the "Internet" connection address</p>
                <p>3. <strong>Firewall:</strong> Make sure Windows Firewall allows Minecraft connections</p>
            </div>
        </div>

        <!-- Server Controls -->
        <div class="card">
            <h3>üéõÔ∏è Server Commands</h3>
            <div>
                <input type="text" id="commandInput" placeholder="Enter server command (e.g., say Hello World)"
                    disabled>
                <button class="button info" onclick="sendCommand()" id="sendBtn" disabled>üì§ Send</button>
            </div>
            <div style="margin-top: 15px;">
                <button class="button info" onclick="sendCommand('list')" id="listBtn" disabled>üë• List Players</button>
                <button class="button info" onclick="sendCommand('time set day')" id="dayBtn" disabled>‚òÄÔ∏è Set
                    Day</button>
                <button class="button info" onclick="sendCommand('weather clear')" id="weatherBtn" disabled>üå§Ô∏è Clear
                    Weather</button>
                <button class="button info" onclick="sendCommand('difficulty easy')" id="diffBtn" disabled>‚öôÔ∏è Easy
                    Mode</button>
            </div>
        </div>

        <!-- Server Console -->
        <div class="card">
            <h3>üìü Server Console</h3>
            <div id="console"></div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        let currentStatus = 'offline';
        let previousStatus = null;
        let statusCheckInterval;
        let lastLoggedUptime = 0;
        let connectionInfoShown = false;
        let socket;

        // Initialize Socket.IO connection
        function initializeSocket() {
            socket = io();

            socket.on('connect', () => {
                log('üîó Connected to server for real-time logs', 'success');
            });

            socket.on('disconnect', () => {
                log('‚ùå Disconnected from server', 'error');
            });

            socket.on('new-log', (logEntry) => {
                displayLog(logEntry);
            });

            socket.on('recent-logs', (logs) => {
                // Display recent logs when page loads
                logs.forEach(logEntry => {
                    displayLog(logEntry, false); // Don't scroll for old logs
                });
            });
        }

        // Display log entry with color coding
        function displayLog(logEntry, shouldScroll = true) {
            const console = document.getElementById('console');
            let color = '#0f0'; // Default green
            let icon = '';

            switch (logEntry.type) {
                case 'error':
                    color = '#ff4444';
                    icon = '‚ùå';
                    break;
                case 'warn':
                    color = '#ffaa00';
                    icon = '‚ö†Ô∏è';
                    break;
                case 'success':
                    color = '#44ff44';
                    icon = '‚úÖ';
                    break;
                case 'player':
                    color = '#44aaff';
                    icon = 'üë§';
                    break;
                case 'world':
                    color = '#aa44ff';
                    icon = 'üåç';
                    break;
                case 'info':
                default:
                    color = '#0f0';
                    icon = '‚ÑπÔ∏è';
                    break;
            }

            const logElement = document.createElement('div');
            logElement.innerHTML = `
                <span style="color: #888">[${logEntry.time}]</span> 
                <span style="color: ${color}">${icon} ${logEntry.message}</span>
            `;

            console.appendChild(logElement);

            // Keep only last 500 log entries to prevent memory issues
            while (console.children.length > 500) {
                console.removeChild(console.firstChild);
            }

            if (shouldScroll) {
                console.scrollTop = console.scrollHeight;
            }
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeSocket();
            startStatusCheck();
        });

        // Start status checking
        startStatusCheck();

        async function startServer() {
            try {
                const response = await fetch('/start', { method: 'POST' });
                const data = await response.json();

                if (data.success) {
                    log(`üöÄ ${data.message}`, 'success');
                    updateUI('starting');
                } else {
                    log(`‚ùå ${data.message}`, 'error');
                }
            } catch (error) {
                log(`‚ùå Error starting server: ${error.message}`, 'error');
            }
        }

        async function stopServer() {
            try {
                const response = await fetch('/stop', { method: 'POST' });
                const data = await response.json();

                if (data.success) {
                    log(`‚èπÔ∏è ${data.message}`, 'info');
                    updateUI('stopping');
                } else {
                    log(`‚ùå ${data.message}`, 'error');
                }
            } catch (error) {
                log(`‚ùå Error stopping server: ${error.message}`, 'error');
            }
        }

        async function sendCommand(cmd = null) {
            const command = cmd || document.getElementById('commandInput').value;
            if (!command) return;

            try {
                const response = await fetch('/command', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command })
                });

                const data = await response.json();
                if (data.success) {
                    log(`üì§ ${data.message}`, 'info');
                    if (!cmd) document.getElementById('commandInput').value = '';
                } else {
                    log(`‚ùå ${data.message}`, 'error');
                }
            } catch (error) {
                log(`‚ùå Error sending command: ${error.message}`, 'error');
            }
        }

        async function refreshStatus() {
            log('üîÑ Manually refreshing status...', 'info');
            await checkStatus(true);
        }

        async function checkStatus(forceLog = false) {
            try {
                const response = await fetch('/status');
                const data = await response.json();

                const statusChanged = data.status !== previousStatus;

                if (statusChanged || forceLog) {
                    handleStatusChange(data.status, data, statusChanged);
                }

                updateUI(data.status, data);

                if (data.status === 'online' && data.connections) {
                    updateConnectionInfo(data.connections, data.publicIP);
                }

                previousStatus = data.status;

            } catch (error) {
                if (forceLog) {
                    log(`‚ùå Status check failed: ${error.message}`, 'error');
                }
                console.error('Status check failed:', error);
            }
        }

        function handleStatusChange(newStatus, data, statusChanged) {
            switch (newStatus) {
                case 'offline':
                    if (statusChanged) {
                        log('‚èπÔ∏è Server is now OFFLINE', 'info');
                        connectionInfoShown = false;
                    }
                    break;

                case 'starting':
                    if (statusChanged) {
                        log('‚ö° Server is STARTING UP...', 'info');
                    }
                    break;

                case 'online':
                    if (statusChanged) {
                        log('üéâ SERVER IS NOW ONLINE! Friends can join!', 'success');
                        connectionInfoShown = true;
                    }
                    break;

                case 'stopping':
                    if (statusChanged) {
                        log('‚è∏Ô∏è Server is STOPPING...', 'info');
                    }
                    break;
            }
        }

        function updateUI(status, data = null) {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            const uptime = document.getElementById('uptime');
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const commandBtns = ['sendBtn', 'listBtn', 'dayBtn', 'weatherBtn', 'diffBtn'];
            const commandInput = document.getElementById('commandInput');

            currentStatus = status;
            indicator.className = 'status-indicator';

            switch (status) {
                case 'offline':
                    indicator.classList.add('status-offline');
                    indicator.innerHTML = '‚èπÔ∏è';
                    text.textContent = 'Server Offline';
                    uptime.classList.add('hidden');
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    commandInput.disabled = true;
                    commandBtns.forEach(id => document.getElementById(id).disabled = true);
                    document.getElementById('connectionInfo').classList.add('hidden');
                    break;

                case 'starting':
                    indicator.classList.add('status-starting', 'loading');
                    indicator.innerHTML = '‚ö°';
                    text.textContent = 'Server Starting...';
                    uptime.classList.remove('hidden');
                    if (data) uptime.textContent = `Starting for ${data.uptime}s`;
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    commandInput.disabled = true;
                    commandBtns.forEach(id => document.getElementById(id).disabled = true);
                    break;

                case 'online':
                    indicator.classList.add('status-online');
                    indicator.innerHTML = '‚úÖ';
                    text.textContent = 'Server Online';
                    uptime.classList.remove('hidden');
                    if (data) uptime.textContent = `Uptime: ${formatUptime(data.uptime)}`;
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    commandInput.disabled = false;
                    commandBtns.forEach(id => document.getElementById(id).disabled = false);
                    document.getElementById('connectionInfo').classList.remove('hidden');
                    break;

                case 'stopping':
                    indicator.classList.add('status-stopping');
                    indicator.innerHTML = '‚è∏Ô∏è';
                    text.textContent = 'Server Stopping...';
                    uptime.classList.add('hidden');
                    startBtn.disabled = true;
                    stopBtn.disabled = true;
                    commandInput.disabled = true;
                    commandBtns.forEach(id => document.getElementById(id).disabled = true);
                    break;
            }
        }

        function updateConnectionInfo(connections, publicIP) {
            const grid = document.getElementById('connectionGrid');

            let html = '';

            html += createConnectionCard('üè† Local Access', 'For you on this computer', [
                { label: 'Java Edition', address: connections.local.java },
                { label: 'Bedrock Edition', address: connections.local.bedrock }
            ]);

            html += createConnectionCard('üèòÔ∏è Network Access', 'For devices on your WiFi', [
                { label: 'Java Edition', address: connections.network.java },
                { label: 'Bedrock Edition', address: connections.network.bedrock }
            ]);

            if (connections.internet) {
                html += createConnectionCard('üåê Internet Access', 'For friends online (requires ngrok/port forwarding)', [
                    { label: 'Java Edition', address: connections.internet.java },
                    { label: 'Bedrock Edition', address: connections.internet.bedrock }
                ]);
            } else {
                html += createConnectionCard('üåê Internet Access', 'Public IP detection failed', [
                    { label: 'Status', address: 'Unable to detect public IP' }
                ]);
            }

            grid.innerHTML = html;
        }

        function createConnectionCard(title, subtitle, connections) {
            let connectionsHtml = connections.map(conn =>
                `<div class="connection-type">${conn.label}:</div>
                 <div class="ip-address">
                     ${conn.address}
                     <button class="copy-btn" onclick="copyToClipboard('${conn.address}')">üìã Copy</button>
                 </div>`
            ).join('');

            return `
                <div class="connection-card">
                    <h4>${title}</h4>
                    <p style="opacity: 0.8; margin-bottom: 15px;">${subtitle}</p>
                    ${connectionsHtml}
                </div>
            `;
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                log(`üìã Copied to clipboard: ${text}`, 'success');
            }).catch(err => {
                log(`‚ùå Failed to copy: ${err.message}`, 'error');
            });
        }

        function formatUptime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;

            if (hours > 0) return `${hours}h ${minutes}m ${secs}s`;
            if (minutes > 0) return `${minutes}m ${secs}s`;
            return `${secs}s`;
        }

        function startStatusCheck() {
            log('üéÆ Minecraft Server Manager loaded', 'success');
            log('üì° Checking initial server status...', 'info');
            checkStatus(true);
            statusCheckInterval = setInterval(() => checkStatus(false), 2000);
        }

        function log(message, type = 'info') {
            // This function now only handles local UI logs
            // Real Minecraft logs come through Socket.IO
            const console = document.getElementById('console');
            const timestamp = new Date().toLocaleTimeString();

            let color = '#0f0';
            switch (type) {
                case 'error': color = '#ff4444'; break;
                case 'warn': color = '#ffaa00'; break;
                case 'success': color = '#44ff44'; break;
                case 'info': default: color = '#0f0'; break;
            }

            const logElement = document.createElement('div');
            logElement.innerHTML = `<span style="color: #888">[${timestamp}]</span> <span style="color: ${color}">${message}</span>`;
            console.appendChild(logElement);

            while (console.children.length > 500) {
                console.removeChild(console.firstChild);
            }

            console.scrollTop = console.scrollHeight;
        }

        document.getElementById('commandInput').addEventListener('keypress', function (e) {
            if (e.key === 'Enter' && !this.disabled) {
                sendCommand();
            }
        });
    </script>

</body>

</html>